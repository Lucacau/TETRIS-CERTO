<!DOCTYPE html>
<html lang="PT-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous"> <!--Collapse-->
    <link rel="stylesheet" href="https://cdn.datatables.net/2.0.0/css/dataTables.dataTables.css"> <!--Datatable-->
    <style>
        :root{ 
            --corPagina: rgb(0, 4, 255);
        }
        *{ 
            margin: 0;
            box-sizing: border-box;
        }
        @font-face {
            font-family: Arcade_I;
            src: url(/TETRIS-SUPREMO/fonts/ARCADE_I.TTF);
        }
        @font-face {
            font-family: Arcade_N;
            src: url(/TETRIS-SUPREMO/fonts/ARCADE_N.TTF);
        }
        @font-face {
            font-family: Arcade_R;
            src: url(/TETRIS-SUPREMO/fonts/ARCADE_R.TTF);
        }
        body{  
            background: black;
            font-family: Arcade_N;  
            font-size: 18px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            text-align: center;
            justify-content: center;
        }  
        #tudo{
            display: flex;
            justify-content: center; 
            gap: 50px;
            align-items: center;
        }
        #tetris{  
            border: solid 0.2em var(--corPagina);  
            height: 90vh;
        }  
        #nextPiece{
            border: solid 0.2em var(--corPagina);  
            height: 25vh;
        }
        #comandos{
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            cursor: pointer;
            outline: none;
            padding: 8px 10px;
            width: 250px;
        }
        #salas{
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            cursor: pointer;
            outline: none;
            padding: 8px 10px;
            width: 250px;
        }
        #comandos-box {
            left: 50%;
            font-size: 10px;
            display: none;
            position: relative;
            background-color: #020202;
            color: white;
            border: 2px solid white;
            border-radius: 5px;
            transform: translateX(-50%);
        }
        #botoes{
            display: flex;
            flex-direction: column;
            gap: 30px;
            align-items: center;
        }
        #startButton{
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            cursor: pointer;
            outline: none;
            padding: 8px 10px;
            width: 250px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameOverScreen {
            display: none;
            position: fixed;
            text-align: center;
            top: 43%;
            left: 50.5%;
            transform: translate(-50%, -50%);
            color: white;
        }
        #logo{
            width: 100%;
            height: 170px;
        }
        .cartao{
            font-size: 14px;
            width: 217px;
            position: relative;
            background-clip: border-box;
            color: var(--corPagina);
            text-align: center;
        }
        #score{
            color: var(--corPagina);  
        }
        #botao-score{
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            cursor: pointer;
            width: 250px;
            padding: 8px 10px;
            outline: none;   
        }
        .corpo-modal{
            display: flex;
            align-items: center;
            justify-content: center;
        }
        @media (min-width: 576px){
        .modal-dialog {
            max-width: 1227px;
            margin: 1.75rem auto;
            padding-block-end: 10px;
        }}
        @media (min-width: 576px){
        .modal-dialog {
            padding: 80px;
        }}
        .modal-content {
            color: var(--corPagina);  
            position: relative;
            display: -webkit-box;
            display: -ms-flexbox;
            display: flex;
            -webkit-box-orient: vertical;
            -webkit-box-direction: normal;
            -ms-flex-direction: column;
            flex-direction: column;
            width: 100%;
            pointer-events: auto;
            background-color: #ffffff;
            background-clip: padding-box;
            border: 1px solid rgba(0,0,0,.2);
            border-radius: 0.3rem;
            outline: 0;
            padding: 0 15px
        }
        #leftside{
            display: flex;
            flex-direction: column;
            gap: 30px;            
        }
        #canva-score{
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        table.dataTable thead th, table.dataTable thead td, table.dataTable tfoot th, table.dataTable tfoot td {
        text-align: center;
        }
        table.dataTable th.dt-type-numeric, table.dataTable th.dt-type-date, table.dataTable td.dt-type-numeric, table.dataTable td.dt-type-date {
        text-align: center;
        }
        .botao-de-exclusao{
            height: 25px;
            width: 25px;
            border: none;
            background: linear-gradient(68.15deg, #4c92ad 16.62%, #9cc5c7 85.61%);
            background-image: url(./img/icone-fermer-et-x-rouge.png);
            background-size: cover;
            cursor:pointer
        }
        #nivel{
            color: var(--corPagina);
        }
        #rightSide{
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
        }
        .fechar{
            float: right;
            font-size: 3rem;
            font-weight: 700;
            line-height: 1;
            color: #ff0000;
            text-shadow: 0 1px 0 #ff0000;
            padding: 1rem;
            margin: -1rem -1rem -1rem auto;
            background-color: transparent;
            border: 0;
            cursor: pointer;
            outline: none;
        }
        #voltar{
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            cursor: pointer;
            width: 250px;
            padding: 8px 10px;
            outline: none; 
        }
        td{
            text-align: center;
        }
        #tentarNovamente{
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            cursor: pointer;
            width: 250px;
            padding: 8px 10px;
            outline: none; 
        }
    </style>
</head>
<body>
    <div id="tudo"> <!--Div englobando tudo-->
        <div id="gameOverScreen" style="display: none;"> <!--Tela de Game Over fica hidden até o gatilho ser ativo-->
            <h1>Game Over!</h1>
        </div>
        <div id="rightSide" style="display: none;">
            <canvas id="tetris" width="240" height="400"></canvas> <!--Canvas principal com o jogo-->
        </div>
        <div id="leftside">  <!--Div englobando a parte esquerda com os botões, score, etc-->
            <img src="/TETRIS-SUPREMO/img/tetris-logo.png" id="logo"> <!--Logo do jogo-->
            <canvas id="nextPiece" style="display: none;" width="80" height="80"></canvas> <!--Quadrado com prox peça-->
            <div id="canva-score" style="display: none;">
                <div id="score"></div>
                <div id="nivel"></div>
                <button onclick="voltarMenu(), buttonClickSound()" id="voltar">Menu</button>
                <button style="display: none;" onclick="start(), buttonClickSound()" id="tentarNovamente">Tentar Novamente</button>
            </div>
            <div id="botoes">
                <button onclick="start(), buttonClickSound()" id="startButton">Singleplayer</button>
                <!-- Button trigger modal -->
                <button onclick= "buttonClickSound()" type="button" id="salas" data-toggle="modal" data-target="#exampleModal">
                    Multiplayer
                </button>
                <!-- Modal -->
                <div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                            <h5 class="modal-title" id="exampleModalLabel">Deseja Criar Uma Sala?</h5>
                            <button onclick= "buttonClickSound()" type="button" class="close" data-dismiss="modal" aria-label="Close">
                                <span aria-hidden="true">&times;</span>
                            </button>
                            </div>
                            <div class="modal-body">
                            Voce precisa de um amigo na mesma rede para jogar um jogo 1 contra 1.
                            </div>
                            <div class="modal-footer">
                                <button onclick= "buttonClickSound()" type="button" class="btn btn-secondary" data-dismiss="modal">Nao</button>
                                <button onclick= "buttonClickSound()" type="button" class="btn btn-primary">Criar Sala</button>
                            </div>
                        </div>
                    </div>
                </div>
                <button onclick= "buttonClickSound()" id="comandos" data-toggle="collapse" data-target="#collapseExample" aria-expanded="false" aria-controls="collapseExample"> <!--Func "buttonClickSound responsável pelo som de click do mine"-->
                    Comandos
                </button>
                <div class="collapse" id="collapseExample"> <!--Collapse com os comandos-->
                    <div class="cartao">
                        < >: Mover<br>
                        🡣: Descer<br>
                        A: Sentido Anti-Horario<br>
                        D: Sentido Horario<br>
                        Espaco: Hard Drop
                    </div>
                </div>
                <button onclick= "buttonClickSound()" type="button" id="botao-score" data-toggle="modal" data-target=".bd-example-modal-lg"> <!--Modal com scoreboard-->
                    Scoreboard
                </button> 
                <div class="modal fade bd-example-modal-lg" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel" aria-hidden="true">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <button onclick= "buttonClickSound()" type="button" class="fechar" data-dismiss="modal" aria-label="Close">
                                <span aria-hidden="true">×</span>
                            </button>
                            <table id="example" class="display" style="width:100%">
                                <thead>
                                    <tr>
                                        <th onclick= "buttonClickSound()">Nome</th>
                                        <th onclick= "buttonClickSound()">Level</th>
                                        <th onclick= "buttonClickSound()">Score</th>
                                        <th onclick= "buttonClickSound()">Data</th>
                                        <th onclick= "buttonClickSound()">Excluir</th>
                                    </tr>
                                </thead>
                                <tbody id="scoreboardBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!--Audios utilizados-->

    <audio id="gameOverSound" src="/TETRIS-SUPREMO/audios/Arcade retro game over sound effect (FREE)_gdrQrCOSFfI.mp3"></audio>
    <audio id="tetrisDropSound" src="/TETRIS-SUPREMO/audios/minecraft-item-drop-sound-effect-pgpbe9afed4_YItRJKGt.mp3"></audio>
    <audio autoplay src="/TETRIS-SUPREMO/audios/Animal Crossing_ City Folk- 2 AM_YsDM3UvXWOc.mp3" loop></audio>
    <audio id="buttonSound" src="/TETRIS-SUPREMO/audios/button-plate-click-minecraft-sound-sound-effect-for-editing-h8y0jmvwdmm_F41koB79.mp3"></audio>
    <audio id="lineClear" src="/TETRIS-SUPREMO/audios/tetris-game-boy-line-clear-sound-effects-lddsf4szgjw_S9wGjWBw.mp3"></audio>

    <script src="https://code.jquery.com/jquery-3.7.1.js"></script> <!--Importação do Jquery-->
    <script src="//cdn.datatables.net/2.0.0/js/dataTables.js"></script> <!--Datatale-->

    <!--Script Responsável pela iniciação da Datatable-->

    <script>
        let scoreboardTable;
        $(document).ready(function() {
            scoreboardTable = $('#example').DataTable({ 
                columnDefs: {
                    target: 2,
                    visible: false,
                    searchable: false
                },
                language: { // Tradução da datatable //
                        "emptyTable": "Nenhum registro encontrado",
                        "info": "",
                        "infoFiltered": "(Filtrados de _MAX_ registros)",
                        "infoThousands": ".",
                        "loadingRecords": "Carregando...",
                        "zeroRecords": "Nenhum registro encontrado",
                        "search": "",
                        "paginate": {
                            "next": "",
                            "previous": "",
                            "first": "",
                            "last": ""
                        },
                        "aria": {
                            "sortAscending": ": Ordenar colunas de forma ascendente",
                            "sortDescending": ": Ordenar colunas de forma descendente"
                        },
                        "select": {
                            "rows": {
                                "_": "Selecionado %d linhas",
                                "1": "Selecionado 1 linha"
                            },
                            "cells": {
                                "1": "1 célula selecionada",
                                "_": "%d células selecionadas"
                            },
                            "columns": {
                                "1": "1 coluna selecionada",
                                "_": "%d colunas selecionadas"
                            }
                        },
                        "buttons": {
                            "copySuccess": {
                                "1": "Uma linha copiada com sucesso",
                                "_": "%d linhas copiadas com sucesso"
                            },
                            "collection": "Coleção  <span class=\"ui-button-icon-primary ui-icon ui-icon-triangle-1-s\"><\/span>",
                            "colvis": "Visibilidade da Coluna",
                            "colvisRestore": "Restaurar Visibilidade",
                            "copy": "Copiar",
                            "copyKeys": "Pressione ctrl ou u2318 + C para copiar os dados da tabela para a área de transferência do sistema. Para cancelar, clique nesta mensagem ou pressione Esc..",
                            "copyTitle": "Copiar para a Área de Transferência",
                            "csv": "CSV",
                            "excel": "Excel",
                            "pageLength": {
                                "-1": "Mostrar todos os registros",
                                "_": "Mostrar %d registros"
                            },
                            "pdf": "PDF",
                            "print": "Imprimir",
                            "createState": "Criar estado",
                            "removeAllStates": "Remover todos os estados",
                            "removeState": "Remover",
                            "renameState": "Renomear",
                            "savedStates": "Estados salvos",
                            "stateRestore": "Estado %d",
                            "updateState": "Atualizar"
                        },
                        "autoFill": {
                            "cancel": "Cancelar",
                            "fill": "Preencher todas as células com",
                            "fillHorizontal": "Preencher células horizontalmente",
                            "fillVertical": "Preencher células verticalmente"
                        },
                        "lengthMenu": "",
                        "searchBuilder": {
                            "add": "Adicionar Condição",
                            "button": {
                                "0": "Construtor de Pesquisa",
                                "_": "Construtor de Pesquisa (%d)"
                            },
                            "clearAll": "Limpar Tudo",
                            "condition": "Condição",
                            "conditions": {
                                "date": {
                                    "after": "Depois",
                                    "before": "Antes",
                                    "between": "Entre",
                                    "empty": "Vazio",
                                    "equals": "Igual",
                                    "not": "Não",
                                    "notBetween": "Não Entre",
                                    "notEmpty": "Não Vazio"
                                },
                                "number": {
                                    "between": "Entre",
                                    "empty": "Vazio",
                                    "equals": "Igual",
                                    "gt": "Maior Que",
                                    "gte": "Maior ou Igual a",
                                    "lt": "Menor Que",
                                    "lte": "Menor ou Igual a",
                                    "not": "Não",
                                    "notBetween": "Não Entre",
                                    "notEmpty": "Não Vazio"
                                },
                                "string": {
                                    "contains": "Contém",
                                    "empty": "Vazio",
                                    "endsWith": "Termina Com",
                                    "equals": "Igual",
                                    "not": "Não",
                                    "notEmpty": "Não Vazio",
                                    "startsWith": "Começa Com",
                                    "notContains": "Não contém",
                                    "notStartsWith": "Não começa com",
                                    "notEndsWith": "Não termina com"
                                },
                                "array": {
                                    "contains": "Contém",
                                    "empty": "Vazio",
                                    "equals": "Igual à",
                                    "not": "Não",
                                    "notEmpty": "Não vazio",
                                    "without": "Não possui"
                                }
                            },
                            "data": "Data",
                            "deleteTitle": "Excluir regra de filtragem",
                            "logicAnd": "E",
                            "logicOr": "Ou",
                            "title": {
                                "0": "Construtor de Pesquisa",
                                "_": "Construtor de Pesquisa (%d)"
                            },
                            "value": "Valor",
                            "leftTitle": "Critérios Externos",
                            "rightTitle": "Critérios Internos"
                        },
                        "searchPanes": {
                            "clearMessage": "Limpar Tudo",
                            "collapse": {
                                "0": "Painéis de Pesquisa",
                                "_": "Painéis de Pesquisa (%d)"
                            },
                            "count": "{total}",
                            "countFiltered": "{shown} ({total})",
                            "emptyPanes": "Nenhum Painel de Pesquisa",
                            "loadMessage": "Carregando Painéis de Pesquisa...",
                            "title": "Filtros Ativos",
                            "showMessage": "Mostrar todos",
                            "collapseMessage": "Fechar todos"
                        },
                        "thousands": ".",
                        "datetime": {
                            "previous": "Anterior",
                            "next": "Próximo",
                            "hours": "Hora",
                            "minutes": "Minuto",
                            "seconds": "Segundo",
                            "amPm": [
                                "am",
                                "pm"
                            ],
                            "unknown": "-",
                            "months": {
                                "0": "Janeiro",
                                "1": "Fevereiro",
                                "10": "Novembro",
                                "11": "Dezembro",
                                "2": "Março",
                                "3": "Abril",
                                "4": "Maio",
                                "5": "Junho",
                                "6": "Julho",
                                "7": "Agosto",
                                "8": "Setembro",
                                "9": "Outubro"
                            },
                            "weekdays": [
                                "Dom",
                                "Seg",
                                "Ter",
                                "Qua",
                                "Qui",
                                "Sex",
                                "Sáb"
                            ]
                        },
                        "editor": {
                            "close": "Fechar",
                            "create": {
                                "button": "Novo",
                                "submit": "Criar",
                                "title": "Criar novo registro"
                            },
                            "edit": {
                                "button": "Editar",
                                "submit": "Atualizar",
                                "title": "Editar registro"
                            },
                            "error": {
                                "system": "Ocorreu um erro no sistema (<a target=\"\\\" rel=\"nofollow\" href=\"\\\">Mais informações<\/a>)."
                            },
                            "multi": {
                                "noMulti": "Essa entrada pode ser editada individualmente, mas não como parte do grupo",
                                "restore": "Desfazer alterações",
                                "title": "Multiplos valores",
                                "info": "Os itens selecionados contêm valores diferentes para esta entrada. Para editar e definir todos os itens para esta entrada com o mesmo valor, clique ou toque aqui, caso contrário, eles manterão seus valores individuais."
                            },
                            "remove": {
                                "button": "Remover",
                                "confirm": {
                                    "_": "Tem certeza que quer deletar %d linhas?",
                                    "1": "Tem certeza que quer deletar 1 linha?"
                                },
                                "submit": "Remover",
                                "title": "Remover registro"
                            }
                        },
                        "decimal": ",",
                        "stateRestore": {
                            "creationModal": {
                                "button": "Criar",
                                "columns": {
                                    "search": "Busca de colunas",
                                    "visible": "Visibilidade da coluna"
                                },
                                "name": "Nome:",
                                "order": "Ordernar",
                                "paging": "Paginação",
                                "scroller": "Posição da barra de rolagem",
                                "search": "Busca",
                                "searchBuilder": "Mecanismo de busca",
                                "select": "Selecionar",
                                "title": "Criar novo estado",
                                "toggleLabel": "Inclui:"
                            },
                            "emptyStates": "Nenhum estado salvo",
                            "removeConfirm": "Confirma remover %s?",
                            "removeJoiner": "e",
                            "removeSubmit": "Remover",
                            "removeTitle": "Remover estado",
                            "renameButton": "Renomear",
                            "renameLabel": "Novo nome para %s:",
                            "renameTitle": "Renomear estado",
                            "duplicateError": "Já existe um estado com esse nome!",
                            "emptyError": "Não pode ser vazio!",
                            "removeError": "Falha ao remover estado!"
                        },
                        "infoEmpty": "",
                        "processing": "Carregando...",
                        "searchPlaceholder": "Buscar registros"
                    },
                order: [ // Ordenação da datatable com base em score, level, data e nome //
                    [3, 'desc'],
                    [2, 'desc'],
                    [4, 'asc'],
                    [0, 'asc'],
                ]
            });
            loadScoreboardData(); // Carregamos as informações salvas no dispositivo assim que carrega a datatable //
        });
    </script>

    <!--Mais importações de collapse e modal-->

    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous">
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous">
    </script>

    <!--Código Principal do jogo-->

    <script>
        "use strict"; //Prevenção de erros de sintaxe, etc//
        const botaoVoltar = document.getElementById('voltar');
        const todosBotoes = document.getElementById('botoes');
        const buttonClick = document.getElementById('buttonSound');
        const gameOverSound = document.getElementById('gameOverSound');
        const tetrisDrop = document.getElementById('tetrisDropSound');
        const clearSound = document.getElementById('lineClear');
        const botaoStart = document.getElementById('startButton');
        const canvas = document.getElementById("tetris"); // Achamos o canvas //
        const context = canvas.getContext("2d"); // Definimos ele como 2d através do context//
        context.scale(20, 20); // Passamos uma escala pra esse contexto //

        function arenaSweep() {   // Função responsável por limpar as linhas da arena e contabilizar pontos //
            let rowCount = 1;  // Definimos a contagem das linhas em 1, é responsável por saber quantas linhas foram removidas de uma vez //
            outer: for (let y = arena.length - 1; y > 0; --y) { // Outer é um comando que permite que você de "break" em um loop externo utilizando um loop interno. Esse loop é responsável por percorrer as linhas e células da arena, começando da ultima e indo ate a primeira. //
                for (let x = 0; x < arena[y].length; ++x) {  // Aqui no caso, atravessa as células da linha atual. //
                    if (arena[y][x] === 0) {  // Se o valor das posições x e y for 0, ele continua com a verificação ignorando a linha atual
                        continue outer;  
                    }  
                }
                const row = arena.splice(y, 1)[0].fill(0); // Caso a linha inteira esteja preenchida com 0, ela é repreenchida com 0, assim, limpando a linha //
                arena.unshift(row); // Agora, essa mesma linha é adicionada a parte decima da arena, fazendo com que as outras linhas venham pra baixo
                ++y; // O ++y é responsável por pular a linha impedindo que o looping externo limpe a linha novamente (causando um bug) //
                lineClearSound(); // Sonzinho pra quando limpar a linha //
                const scoreMultiplier = Math.pow(2, player.level - 1); // Ajuste para multiplicador de pontuação baseado no nível (ex: 2^(level-1))
                player.score += rowCount * 6 * scoreMultiplier; // Pontuação ajustada com base no multiplicador de pontuação
            }  
        }  
        function collide(arena, player) {  // Função para verificarmos a colisão da peça do jogador com as paredes, fundo da arena ou com outras peças. //
            const m = player.matrix; // Definimos M como a matriz do jogador (peça atual) //
            const o = player.pos; // Definimos O como a posição atual do jogador //
            for (let y = 0; y < m.length; ++y) { // Looping externo responsável por verificar se no eixo Y, irá haver colisão //
                for (let x = 0; x < m[y].length; ++x) { // Mesma coisa para o eixo X //
                    if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {  // Este if é responsável por verificar se os valores de X e Y do jogador e da arena são diferentes de zero, levando em consideração de que ambos só serão considerados colididos caso estejam no mesmo espaço da matriz. //
                        return true; // Retorna true caso tenha 2 valores diferentes de 0 no mesmo espaço //
                    }  
                }  
            }  
            return false;
        }  
        function createMatrix(w, h) {  // Função para criar a matrix do jogo de acordo com a altura e largura desejados. Nada muito complexo //
            const matrix = []; // A matrix é definida como uma array vazia //
            while (h--) {  // Enquanto a altura estiver diminuindo, ele continau preenchendo a matrix com "0" //
                matrix.push(new Array(w).fill(0));
            }  
            return matrix; // Dito isso, agora a função retorna a matrix como uma array preenchida com "0" em toda a sua altura e largura. //
        }  
        function createPiece(type) {  // Função para a criação das peças //
            if (type === "I") {  
                return [ // Brinque como quiser com o formato dessas peças KASKASKKAS //
                    [0, 1, 0, 0],  
                    [0, 1, 0, 0],  
                    [0, 1, 0, 0],  
                    [0, 1, 0, 0],  
                ];  
            } else if (type === "L") {  
                return [  
                    [0, 2, 0],  
                    [0, 2, 0],  
                    [0, 2, 2],  
                ];  
            } else if (type === "J") {  
                return [  
                    [0, 3, 0],  
                    [0, 3, 0],  
                    [3, 3, 0],  
                ];  
            } else if (type === "O") {  
                return [  
                    [4, 4],  
                    [4, 4],  
                ];  
            } else if (type === "Z") {  
                return [  
                    [5, 5, 0],  
                    [0, 5, 5],  
                    [0, 0, 0],  
                ];  
            } else if (type === "S") {  
                return [  
                    [0, 6, 6],  
                    [6, 6, 0],  
                    [0, 0, 0],  
                ];  
            } else if (type === "T") {  
                return [  
                    [0, 7, 0],  
                    [7, 7, 7],  
                    [0, 0, 0],  
                ];  
            }  
        }  
        function drawMatrix(matrix, offset) { // Esta função é responsável por dar cor as peças e desenhar elas no campo, mas ela só será chamada daqui a pouco //
            matrix.forEach((row, y) => {  
                row.forEach((value, x) => {  
                    if (value !== 0) { // Aqui passamos por cada valor diferente de 0 no eixo X e Y de uma peça, dito isso, caso o valor seja diferente de "0", ("1","2","3", etc) a função pinta a célula de acordo com a peça. (Caso seja "1", "2" e assim por diante). //
                        const gradient = context.createLinearGradient(x + offset.x, y + offset.y, x + offset.x + 1, y + offset.y + 1);
                        switch(value) {
                            case 1: // Peça I (Vermelho neon)
                                gradient.addColorStop(0, '#FF3E4D');
                                gradient.addColorStop(1, '#FFA07A');
                                break;
                            case 2: // Peça L (Azul neon)
                                gradient.addColorStop(0, '#00FFFF');
                                gradient.addColorStop(1, '#6A5ACD');
                                break;
                            case 3: // Peça J (Verde neon)
                                gradient.addColorStop(0, '#39DF14');
                                gradient.addColorStop(1, '#000F7F');
                                break;
                            case 4: // Peça O (Amarelo neon)
                                gradient.addColorStop(0, '#FFFF00');
                                gradient.addColorStop(1, '#FF6700');
                                break;
                            case 5: // Peça Z (Roxo neon)
                                gradient.addColorStop(0, '#BF04FF');
                                gradient.addColorStop(1, '#0122CC');
                                break;
                            case 6: // Peça S (Rosa neon)
                                gradient.addColorStop(0, '#FF1493');
                                gradient.addColorStop(1, '#FF69B4');
                                break;
                            case 7: // Peça T (Laranja neon)
                                gradient.addColorStop(0, '#FFA500');
                                gradient.addColorStop(1, '#FF4500');
                                break;
                        }
                        context.fillStyle = gradient;
                        context.fillRect(x + offset.x, y + offset.y, 1, 1);
                        context.fillStyle = 'rgba(255, 255, 255, 0.05)';
                        context.fillRect(x + offset.x, y + offset.y, 1, 1);
                    }  
                });  
            });  
        }

        function drawNextPiece(piece) { // Função responsável por criar o quadradinho que mostra a proxima peça (e já mostrar ela como consequência) //
            const canvasNextPiece = document.getElementById("nextPiece");
            const contextNextPiece = canvasNextPiece.getContext("2d"); // Definimos o mesmo contexto de 2d, mas dessa vez não damos os parâmetros anteriores de 20x20 //

            contextNextPiece.clearRect(0, 0, canvasNextPiece.width, canvasNextPiece.height); // Esta linha da clear no quadradinho para previnir que não haja alguma peça ali e quando a outra aparecer, não acabar sobrescrevendo a anterior //

            const cellSize = canvasNextPiece.width / 5; // Definimos um quadradinho de "5x5" //
            const offsetX = (canvasNextPiece.width - piece[0].length * cellSize) / 2; // Estas duas linhas são responsáveis pela localização da peça no quadradinho, se vai ser no centro ou onde der pra ajustar //
            const offsetY = (canvasNextPiece.height - piece.length * cellSize) / 2; 
            piece.forEach((row, y) => { // Aqui fazemos a mesma coisa da func anterior para dar cor as peças que irão aparecer //
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const gradient = contextNextPiece.createLinearGradient(x * cellSize + offsetX, y * cellSize + offsetY, (x + 1) * cellSize + offsetX, (y + 1) * cellSize + offsetY);
                        switch (value) {
                            case 1: // Peça I (Vermelho neon)
                                gradient.addColorStop(0, '#FF3E4D');
                                gradient.addColorStop(1, '#FFA07A');
                                break;
                            case 2: // Peça L (Azul neon)
                                gradient.addColorStop(0, '#00FFFF');
                                gradient.addColorStop(1, '#6A5ACD');
                                break;
                            case 3: // Peça J (Verde neon)
                                gradient.addColorStop(0, '#39DF14');
                                gradient.addColorStop(1, '#000F7F');
                                break;
                            case 4: // Peça O (Amarelo neon)
                                gradient.addColorStop(0, '#FFFF00');
                                gradient.addColorStop(1, '#FF6700');
                                break;
                            case 5: // Peça Z (Roxo neon)
                                gradient.addColorStop(0, '#BF04FF');
                                gradient.addColorStop(1, '#0122CC');
                                break;
                            case 6: // Peça S (Rosa neon)
                                gradient.addColorStop(0, '#FF1493');
                                gradient.addColorStop(1, '#FF69B4');
                                break;
                            case 7: // Peça T (Laranja neon)
                                gradient.addColorStop(0, '#FFA500');
                                gradient.addColorStop(1, '#FF4500');
                                break;
                        }
                        contextNextPiece.fillStyle = gradient;
                        contextNextPiece.fillRect(x * cellSize + offsetX, y * cellSize + offsetY, cellSize, cellSize);
                        contextNextPiece.fillStyle = 'rgba(255, 255, 255, 0.05)';
                        contextNextPiece.fillRect(x * cellSize + offsetX, y * cellSize + offsetY, cellSize, cellSize);
                    }
                });
            });
        }
        
        // Duas func de som que tão meio perdidas ai //

        function buttonClickSound(){
            buttonClick.play();
        }
        
        function lineClearSound(){
            clearSound.play();
        }
        function voltarMenu(){
            todosBotoes.style.display = "flex";
            document.getElementById('gameOverScreen').style.display = "none";
            document.getElementById("nextPiece").style.display = "none";
            document.getElementById('rightSide').style.display = 'none';
            document.getElementById('canva-score').style.display = 'none';
            dropInterval = 9999999; // Drop Interval infinito pra nao cair nenhuma peça //
            player.pos.y = -10; // Jogamos as peças 10 px pra cima do canvas, assim ngm vai ver a peça ali paradinha //
            stopLevelUpdate() // Paramos a contagem de lvl //
        }
        function draw() {  // Func responsável por fazer o fundinho da arena //
            context.fillStyle = "#000"; // Definimos o fundinho como preto (experimenta por rosa pra vc ver que engraçado) //
            context.fillRect(0, 0, canvas.width, canvas.height); // Colocamos essa cor em toda a extenção do canva //
            drawMatrix(arena, {x: 0, y: 0}); // Colocação da peça em campo no local (arena) e posição que queremos. //
            drawGhostPiece(); // Optei por colocar a função de ghostpiece aqui pois assim que surge alguma peça, já é identificada qual peça é e em qual posição ela está com base no offset (posição) dela. Mais tarde essa função vai ser melhor explicada //
            drawMatrix(player.matrix, player.pos); // Chamamos novamente a draw matrix para a matriz e para a posição atual do jogador, definida no final do código //
        }  
        function merge(arena, player) {  // Função para integrar a peça ao campo, junto a matriz e as outras peças do jogador //
            player.matrix.forEach((row, y) => {  
            row.forEach((value, x) => {  
                if (value !== 0) {  // Percorremos novamente por cada linha e em cada célula verificando se o valor é diferente de 0. Se for, ele define que essa posição atual da peça agora será o novo valor nas posições x e y tanto da arena quanto do jogador. //
                arena[y + player.pos.y][x + player.pos.x] = value;  
                }  
            });  
        });  
        }  
        function rotate(matrix, dir) { // Func responsável por rotacionar a peça //
            for (let y = 0; y < matrix.length; ++y) { 
                for (let x = 0; x < y; ++x) { 
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; // Dentro do loop, os elementos são trocados de posição, então, o que era x vira y e o que era y vira x (bem confuso) // 
                }  
            }  
            if (dir > 0) { // Se o valor for positivo, rotaciona em sentido horário, se for negativo, rotaciona no inverso (anti-horário) //
                matrix.forEach((row) => row.reverse());  
            } 
            else {  
                matrix.reverse();  
            }  
        } 
        function playerDrop() { // Func para a peça simplesmente cair //
            player.pos.y++;
            if (collide(arena, player)) { // Se colidir com alguma coisa enquanto estiver caindo: volta 1 posição do eixo y para que a peça não fique dentro da outra. Irei tentar explicar por texto como funciona a colisão: Se a peça entrar dentro da arena ou de outra peça (cujos valores são diferentes de 0), a func collide retorna o valor true, dizendo que ali houve colisão de dois corpos. //
                player.pos.y--; // Dito isso, agora volta 1 posição //
                merge(arena, player); // Integra a posição daquela peça a arena fazendo com que fique "fixa" ali //
                playerReset(); // Faz uma nova peça aparecer no campo //
                arenaSweep(); // Chama a função que percorre a arena para verificar se houve uma linha inteira preenchida com valor diferente de 0, se houver, já limpa e conta a pontuação //
                updateScore(); // Atualiza o score do jogador //
            }
            dropCounter = 0; // Define também a contagem de "dropagem" (não consigo pensar em outro termo) em 0. //
        }
        function playerMove(offset) {  // Função para mover a peça do jogador. //
            player.pos.x += offset;  // Posição no eixo X do jogador somada a posição passada no parâmetro //
            if (collide(arena, player)) {  // Se colidir, o eixo X do jogador é impedido de progredir pois sempre será subtraida pela posição //
                player.pos.x -= offset;  
            }  
        }  

        let shuffledPieces = shufflePieces(); // Definimos uma variável com as peças embaralhadas //

        function shufflePieces() { // Func para embaralhar as peças (balancear o jogo) //
            const pieces = "TJLOSZI".split(''); // Pegamos todas as peças e dividimos todas em strings únicas //
            // Embaralhe as peças usando o algoritmo de Fisher-Yates //
            for (let i = pieces.length - 1; i > 0; i--) { // Looping para sempre pegar peças diferentes e nunca repetir duas peças seguidas //
                const j = Math.floor(Math.random() * (i + 1)); // Faz aquela parada maluca do fisher-yates que nao sei explicar //
                [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
            }
            return pieces; // Retorna essas peças agora embaralhadas //
        }
        const pieceFrequency = { // Define que cada uma das peças agora tem um valor inicial de "0", que logo será aumentado //
            "T": 0,
            "J": 0,
            "L": 0,
            "O": 0,
            "S": 0,
            "Z": 0,
            "I": 0
        };
        function playerReset() { // Função que faz a peça aparecer no campo //
            const selectedPiece = shuffledPieces.pop(); // Pegamos a peça que irá aparecer e dizemos que essa peça será a última peça do array de peças embaralhadas // 
            
            drawNextPiece(createPiece(shuffledPieces[shuffledPieces.length - 1])); // aqui dizemos que a próxima peça a aparecer no quadradinho de próximas peças, será o valor das peças embaralhadas - 1, dito isso, será uma peça depois da peça atualmente em campo. //
            
            player.matrix = createPiece(selectedPiece); // Criamos a peça com a peça já escolhida das peças embaralhadas //
            player.pos.y = 0; // Definimos que ela irá aparecer nesta posição do eixo Y e X //
            player.pos.x = Math.floor((arena[0].length / 2) - (player.matrix[0].length / 2));
            
            if (collide(arena, player)) { // Se agora a peça do jogador colidir com a nova peça desenhada, será retornada a função de gameOver, que para o jogo, já já chegamos nela. //
                gameOver(player.level);
                return;
            }
            pieceFrequency[selectedPiece]++; // Aqui aumentamos a frequência de peças daquela array anterior que definimos como 0, essa frequência será adicionada com base na peça selecionada atualmente, fazendo com que sempre haja esse balanceamento correto das peças //

            shuffledPieces.unshift(selectedPiece); // Faz com que a peça selecionada seja adicionada ao array de peças embaralhadas na última posição, fazemdo com que haja uma fila que será sempre reembaralhada //
        }

        function playerRotate(dir) {  // Func que irá rotacionar a peça //
            const pos = player.pos.x; // Definie a posição como a posição X do jogador para caso não seja possível rotacionar, sendo assim, volta a posição original //
            let offset = 1; // Define a posição offset como 1 //
            rotate(player.matrix, dir); // Chama a func rotate com os parâmetros da peça do jogador e em qual posição ele irá rotacionar (positiva ou negativa)
            while (collide(arena, player)) { // Definimos um loop para caso a peça esteja colidindo com algum elemento //
                player.pos.x += offset; // Basicamente nas linhas abaixo, os valores são verificados para compreender se serão positivos ou negativos. Caso haja um valor positivo, a peça tentará rotacionar para a direita, enquanto o contrário ocorrerá para o outro lado. Quando chegamos no if, ele verifica se há possibilidade de rotacionar para qualquer lado, se não for possível, só retornamos a posição original (salva na constante "pos"). //
                offset = -(offset + (offset > 0 ? 1 : -1));  
                if (offset > player.matrix[0].length) {  
                    rotate(player.matrix, -dir);  
                    player.pos.x = pos;
                    return;  
                }  
            }  
        }
        function start(){ // Função para começar o jogo //
            $('#startButton').blur(); // Tiramos o foco do botão //
            document.getElementById('tentarNovamente').style.display = "none";
            document.getElementById("nextPiece").style.display = "flex";
            todosBotoes.style.display = "none";
            document.getElementById('rightSide').style.display = 'flex';
            document.getElementById('canva-score').style.display = 'flex';
            arena.forEach((row) => row.fill(0)); // Primeiro limpamos toda a arena para caso houvesse alguma peça nela (caso seja a segunda vez jogando) //
            playerReset(); // Chamamos a função que gera peça //
            update(); // Chamamos a função que atualiza o jogo a todo instante //
            document.getElementById('gameOverScreen').style.display = 'none'; // Definimos que agora a tela de gameOver deve estar escondida dnv caso seja a segunda vez jogando (ou mais) //
            dropInterval = 500; // Definimos novamente o drop interval para 500 //
            player.score = 0; // O score é resetado para 0 também //
            updateScore(); // Atualizamos o score na tela //
            stopLevelUpdate(); // Pare o intervalo de atualização do nível antes de iniciar um novo jogo //
            player.level = 0; // Redefina o nível do jogador para o valor inicial //
            showLevel(); // Mostramos o lvl atualizado na tela //
            startLevelUpdate(); // Começamos novamente a contar o level //
        }
        function showGameOver() { // Só mostramos a tela de gameOver na tela //
            document.getElementById('gameOverScreen').style.display = 'block';
        }
        // Defina uma variável para controlar o intervalo de atualização do nível
        let levelUpdateInterval; // Variável que vai armazenar o intervalo que o lvl vai aumentar //

        // Função para atualizar o nível do jogador com base no tempo decorrido //
        function updateLevel() {
            player.level++; // Aumenta o nível do jogador //
            dropInterval -= 20; // Reduz o intervalo de queda para aumentar a velocidade do jogo //
            showLevel(); // Atualiza a exibição do nível //
        }
        // Função para iniciar o intervalo de atualização do nível //
        function startLevelUpdate() {
            levelUpdateInterval = setInterval(updateLevel, 20000); // Atualiza o nível a cada 20 segundos //
        }

        // Função para parar o intervalo de atualização do nível (se necessário) //
        function stopLevelUpdate() {
            clearInterval(levelUpdateInterval);
        }

        // Função para exibir o nível do jogador //
        function showLevel() {
            let nivelJogador = String(player.level).padStart(2, '0'); // Colocamos 3 zeros na tela //
            document.getElementById("nivel").innerText = "Level: " + nivelJogador; // Adicionamos o lvl atual com a string "Level" //
        }
        function gameOver(nivelJogador) { // Função que acaba com o jogo (o parâmetro está ai pois foi a única maneira que consegui incluir o level atual do jogador na datatable) //
            document.getElementById('tentarNovamente').style.display = "flex";
            gameOverSound.play(); // Toca o som de fim //
            showGameOver(); // Mostra a tela de game over //
            dropInterval = 9999999; // Drop Interval infinito pra nao cair nenhuma peça //
            player.pos.y = -10; // Jogamos as peças 10 px pra cima do canvas, assim ngm vai ver a peça ali paradinha //
            stopLevelUpdate() // Paramos a contagem de lvl //
            let nomeSemEspaco = prompt("Digite seu nome:");
            var playerName = nomeSemEspaco.trim();
            playerName = playerName.substring(0, 14);
            

            const date = new Date().toLocaleDateString(); // Salvamos a data e score atual do jogador //
            const score = player.score;


            addScoreToTable(playerName, nivelJogador, score, date);

            saveScoreboardData(); // Salvamos as informações do scoreboard nesta função //
        }
        function playerHardDrop() { // função de HardDrop //
            const originalPos = { ...player.pos }; // Copiamos a posição atual do jogador nesta constante //
            while (!collide(arena, player)) { // Enquanto não colidir, aumenta o Y o máximo que conseguir //
                player.pos.y++;
            }
            player.pos.y--; // Voltamos 1 quando colidir //
            if (!collide(arena, player)) { // Como voltamos uma posição, agora enquanto não colidir, podemos mover a peça para os lados depois de dar hard drop para podermos fazer a jogadinha 😎 //
                var moveDelay = 100; // Delay de 100 ms para ser difícel de fazer a jogadinha //
                let currentTime = performance.now(); // Usamos performance pois como queremos ter uma precisão muito exata, o performance é o único que consegue entregar tanta precisão de resposta //
                let allowMove = true; // Permitimos o movimento //

                const moveHandler = (event) => {
                    if (allowMove) { // Se for permitido o movimento, escreva sua história 🤠 //
                        if (event.keyCode === 37) { 
                            playerMove(-1);
                            allowMove = false; 
                        } else if (event.keyCode === 39) { 
                            playerMove(1);
                            allowMove = false; 
                        }
                    }
                };

                document.addEventListener("keydown", moveHandler);

                setTimeout(() => {
                    document.removeEventListener("keydown", moveHandler);
                }, moveDelay);
            }
        }

        function drawGhostPiece() { // Func que irá desenhar a peça fantasma na arena //
            let ghostPiecePosition = { ...player.pos }; // Copia a posição do jogador //
            while (!collide(arena, { matrix: player.matrix, pos: { ...ghostPiecePosition } })) { // Enquanto a peça copiada do jogador não colidir com a arena, ele incrementa a ghostpiece no eixo y //
                ghostPiecePosition.y++;
            }
            ghostPiecePosition.y--; // Quando colidir, volta 1 posição do eixo Y //

            player.matrix.forEach((row, y) => { // Definimos uma corzinha transparente e escura para a peça fantasma //
                row.forEach((value, x) => {  
                    if (value !== 0) {
                        context.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        context.fillRect(x + ghostPiecePosition.x, y + ghostPiecePosition.y, 1, 1);
                    }
                });
            });
        }
 
        function addScoreToTable(playerName, nivelJogador, score, date) { // Função para adicionar todas as informações salvas anteriormente na datatable //
            if (scoreboardTable) {
                const deleteButton = `<button class="botao-de-exclusao" onclick="deleteScore(event), buttonClickSound()"></button>`;
                scoreboardTable.row.add([ // Adiciona essas informações na datatable //
                    playerName,
                    nivelJogador,
                    score,
                    date,
                    deleteButton,
                ])  .draw(); 
            }
        }
        function deleteScore(event) { // Função para apagar a linha da datatable com o botaozinho (essa função é chamada no "deleteButton" // 
            const row = event.target.closest('tr'); // Identificamos o TR mais próximo e definimos que ele será nossa constante "row" (linha) //
            const rowIndex = scoreboardTable.row(row).index(); // Obtém o índice da linha na tabela
            const data = JSON.parse(localStorage.getItem('scoreboardData')); // Deifinimos que os dados são as informações salvas dentro do JSON localStorage //
            if (data) {
                data.splice(rowIndex, 1); // Remove os dados associados ao índice da linha
                localStorage.setItem('scoreboardData', JSON.stringify(data));
            }
            scoreboardTable.row(row).remove().draw(); // Removemos a linha //
        }
        function loadScoreboardData() { // Carregamos as informações anteriormente salvas no localStorage //
            const data = localStorage.getItem('scoreboardData'); // Pegamos as info salvas //
            if (data) {
                const scoreboardData = JSON.parse(data);
                scoreboardData.forEach(row => {
                    addScoreToTable(row[0], row[1], row[2], row[3], row[5]); // Adicionamos elas em local certinho //
                });
            }
        } 
        function saveScoreboardData() { // Função para salvarmos as informações no localStorage //
            const data = scoreboardTable.rows().data().toArray(); 
            localStorage.setItem('scoreboardData', JSON.stringify(data));
        }
        function showControls() { // Collapse que mostra os comandos //
            controlsBox.style.display = "block";
        }
        let dropCounter = 0; // Variável que define a contagem de drops em 0 //
        let dropInterval = 1000; // Variável que define o intervalo de drop das peças em 1000 ms //
        let lastTime = 0; // Variável que usaremos para atualizar o jogo //
        function update(time = 0) { // Função para atualizar o jogo a todo o momento //
            const deltaTime = time - lastTime; // Calcula o intervalo entre o tempo atual e o último atualizado //
            dropCounter += deltaTime; // Adiciona o tempo atualizado com o dropCounter para controlar a velocidade do jogo //
            if (dropCounter > dropInterval) { // Verifica se o valor atualizado excede o valor de queda //
                playerDrop(); // Se sim, cai uma linhazinha
            }  
            lastTime = time; // Atualizamos agora o lastTime como o Time atual para que depois, quando a função for chamada novamente, sempre salve a atualização correta //
            draw(); // Atualiza o jogo //
            requestAnimationFrame(update); // Inicializa um loop infinito que sempre atualiza o jogo a todo o instante enquanto estiver em execução // 
        }  
        function updateScore() {  // Atualiza o score na tela //
            let formattedScore = String(player.score).padStart(4, '0');  
            document.getElementById("score").innerText = "Score: " + formattedScore;  
        } 
        
        // Movimentação do jogador //

        document.addEventListener("keydown", (event) => {  
            if (event.keyCode === 37) {  
                playerMove(-1);  
            } 
            else if (event.keyCode === 39) {  
                playerMove(1);  
            } 
            else if (event.keyCode === 40) {  
                playerDrop();  
            } 
            else if (event.keyCode === 65) {  
                playerRotate(-1);  
            } 
            else if (event.keyCode === 68) {  
                playerRotate(1);  
            }  
            else if (event.keyCode === 32) { // Tecla de espaço para hard drop
                playerHardDrop();
                tetrisDrop.play();
            }
        });  
        // Definimmos o quadradinho como 5x5 //
        const arenaNextPiece = createMatrix(5, 5);
        // Definimos a arena como 12x20 //
        const arena = createMatrix(12, 20);  
        // Fazemos todas as variações para o player
        const player = {  
            pos: { x: 0, y: 0 },  
            matrix: null,  
            score: 0,  
            level: 0,
        };
        // Atualizamos o score quando inicia a página //
        updateScore();
        // Atualizamos o lvl quando inicia a página //
        showLevel();
    </script>
</body>
</html>