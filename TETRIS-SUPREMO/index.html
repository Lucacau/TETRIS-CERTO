<!DOCTYPE html>
<html lang="PT-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous"> <!--Collapse-->
    <link rel="stylesheet" href="https://cdn.datatables.net/2.0.0/css/dataTables.dataTables.css"> <!--Datatable-->
    <style>
        :root{ 
            --corPagina: rgb(0, 4, 255);  ;
        }
        *{ 
            margin: 0;
            box-sizing: border-box;
        }
        @font-face {
            font-family: Arcade_I;
            src: url(/fonts/ARCADE_I.TTF);
        }
        @font-face {
            font-family: Arcade_N;
            src: url(/fonts/ARCADE_N.TTF);
        }
        @font-face {
            font-family: Arcade_R;
            src: url(/fonts/ARCADE_R.TTF);
        }
        body{  
            background: black;
            font-family: Arcade_N;  
            font-size: 18px;
        }  
        .tudo{
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            margin-top: 40px;
            
        }
        #tetris{  
            border: solid 0.2em var(--corPagina);  
            height: 90vh;
        }  
        #nextPiece{
            border: solid 0.2em var(--corPagina);  
            height: 25vh;
        }
        #comandos{
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            height: 50px;
            cursor: pointer;
            width: 150px;
            outline: none;
        }
        #salas{
            display: flex;
            align-items: center;
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            height: 50px;
            cursor: pointer;
            width: 150px;
            outline: none;
        }
        #comandos-box {
            left: 50%;
            font-size: 10px;
            display: none;
            position: relative;
            background-color: #020202;
            color: white;
            border: 2px solid white;
            border-radius: 5px;
            transform: translateX(-50%);
        }
        .botoes{
            display: flex;
            flex-direction: column;
            gap: 30px;
            align-items: center;
        }
        #startButton{
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            height: 50px;
            cursor: pointer;
            width: 150px;
            outline: none;
            display: flex;
            align-items: center;
        }
        #gameOverScreen {
            display: none;
            position: fixed;
            text-align: center;
            top: 43%;
            left: 50.5%;
            transform: translate(-50%, -50%);
            color: white;
        }
        #logo{
            height: 150px;
        }
        .cartao{
            font-size: 14px;
            width: 217px;
            position: relative;
            background-clip: border-box;
            color: var(--corPagina);
            text-align: center;
        }
        #score{
            color: var(--corPagina);  
        }
        #botao-score{
            display: flex;
            align-items: center;
            font-family: Arcade_N;
            background-color: var(--corPagina);  
            color: white;
            border: 10px;
            border-radius: 10px;
            height: 50px;
            cursor: pointer;
            width: 150px;
            outline: none;   
        }
        .corpo-modal{
            display: flex;
            align-items: center;
            justify-content: center;
        }
        @media (min-width: 576px){
        .modal-dialog {
            max-width: 1227px;
            margin: 1.75rem auto;
            padding-block-end: 10px;
        }}
        @media (min-width: 576px){
        .modal-dialog {
            padding: 80px;
        }}
        .modal-content {
            color: var(--corPagina);  
            position: relative;
            display: -webkit-box;
            display: -ms-flexbox;
            display: flex;
            -webkit-box-orient: vertical;
            -webkit-box-direction: normal;
            -ms-flex-direction: column;
            flex-direction: column;
            width: 100%;
            pointer-events: auto;
            background-color: #ffffff;
            background-clip: padding-box;
            border: 1px solid rgba(0,0,0,.2);
            border-radius: 0.3rem;
            outline: 0;
            padding: 37px;
        }
        #leftside{
            display: flex;
            flex-direction: column;
            gap: 30px;            
        }
        #canva-score{
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        table.dataTable thead th, table.dataTable thead td, table.dataTable tfoot th, table.dataTable tfoot td {
        text-align: center;
        }
        table.dataTable th.dt-type-numeric, table.dataTable th.dt-type-date, table.dataTable td.dt-type-numeric, table.dataTable td.dt-type-date {
        text-align: center;
        }
        .botao-de-exclusao{
            height: 25px;
            width: 25px;
            border: none;
            background: linear-gradient(68.15deg, #4c92ad 16.62%, #9cc5c7 85.61%);
            background-image: url(/img/icone-fermer-et-x-rouge.png);
            background-size: cover;
            cursor:pointer
        }
        #nivel{
            color: var(--corPagina);
        }
        #rightSide{
            display: flex;
            align-items: center;
            gap: 30px;
        }
    </style>
</head>
<body>
    <div class="tudo"> <!--Div englobando tudo-->
        <div id="gameOverScreen" style="display: none;"> <!--Tela de Game Over fica hidden atÃ© o gatilho ser ativo-->
            <h1>Game Over!</h1>
        </div>
        <div id="leftside">  <!--Div englobando a parte esquerda com os botÃµes, score, etc-->
            <div id="canva-score" style="display: none;">
                <div id="score"></div>
                <div id="nivel"></div>
            </div>
            <img src="/img/tetris-logo.png" id="logo"> <!--Logo do jogo-->
            <div class="botoes">
                <button onclick="start(), buttonClickSound()" id="startButton">Single Player</button>
                <!-- Button trigger modal -->
                <button type="button" id="salas" data-toggle="modal" data-target="#exampleModal">
                    Multi Player
                </button>
                <!-- Modal -->
                <div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                            <h5 class="modal-title" id="exampleModalLabel">Deseja Criar Uma Sala?</h5>
                            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                                <span aria-hidden="true">&times;</span>
                            </button>
                            </div>
                            <div class="modal-body">
                            Voce precisa de um amigo na mesma rede para jogar um jogo 1 contra 1.
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-dismiss="modal">Nao</button>
                                <button type="button" class="btn btn-primary">Criar Sala</button>
                            </div>
                        </div>
                    </div>
                </div>
                <button onclick= "buttonClickSound()" id="comandos" data-toggle="collapse" data-target="#collapseExample" aria-expanded="false" aria-controls="collapseExample"> <!--Func "buttonClickSound responsÃ¡vel pelo som de click do mine"-->
                    Comandos
                </button>
                <div class="collapse" id="collapseExample"> <!--Collapse com os comandos-->
                    <div class="cartao">
                        < >: Mover<br>
                        ðŸ¡£: Descer<br>
                        A: Sentido Anti-Horario<br>
                        D: Sentido Horario<br>
                        Espaco: Hard Drop
                    </div>
                </div>
                <button onclick= "buttonClickSound()" type="button" id="botao-score" data-toggle="modal" data-target=".bd-example-modal-lg"> <!--Modal com scoreboard-->
                    Score Board
                </button> 
                <div class="modal fade bd-example-modal-lg" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel" aria-hidden="true">
                    <div class="modal-dialog modal-lg">
                        <div class="modal-content">
                            <table id="example" class="display" style="width:100%">
                                <thead>
                                    <tr>
                                        <th>Nome</th>
                                        <th>Sobrenome</th>
                                        <th>Level</th>
                                        <th>Score</th>
                                        <th>Data</th>
                                        <th>Excluir</th>
                                    </tr>
                                </thead>
                                <tbody id="scoreboardBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="rightSide" style="display: none;">
            <canvas id="tetris" width="240" height="400"></canvas> <!--Canvas principal com o jogo-->
            <canvas id="nextPiece" width="80" height="80"></canvas> <!--Quadrado com prox peÃ§a-->
        </div>
    </div>

    <!--Audios utilizados-->

    <audio id="gameOverSound" src="/audios/Arcade retro game over sound effect (FREE)_gdrQrCOSFfI.mp3"></audio>
    <audio id="tetrisDropSound" src="/audios/minecraft-item-drop-sound-effect-pgpbe9afed4_YItRJKGt.mp3"></audio>
    <audio autoplay id="tetrisBackgroundMusic" src="/audios/Animal Crossing_ City Folk- 2 AM_YsDM3UvXWOc.mp3" loop></audio>
    <audio id="buttonSound" src="/audios/button-plate-click-minecraft-sound-sound-effect-for-editing-h8y0jmvwdmm_F41koB79.mp3"></audio>
    <audio id="lineClear" src="/audios/tetris-game-boy-line-clear-sound-effects-lddsf4szgjw_S9wGjWBw.mp3"></audio>

    <script src="https://code.jquery.com/jquery-3.7.1.js"></script> <!--ImportaÃ§Ã£o do Jquery-->
    <script src="//cdn.datatables.net/2.0.0/js/dataTables.js"></script> <!--Datatale-->

    <!--Script ResponsÃ¡vel pela iniciaÃ§Ã£o da Datatable-->

    <script>
        let scoreboardTable;
        $(document).ready(function() {
            scoreboardTable = $('#example').DataTable({ 
                order: [ // OrdenaÃ§Ã£o da datatable com base em score, level, data e nome //
                    [3, 'desc'],
                    [2, 'desc'],
                    [4, 'asc'],
                    [0, 'asc'],
                ]
            });
            loadScoreboardData(); // Carregamos as informaÃ§Ãµes salvas no dispositivo assim que carrega a datatable //
        });
    </script>

    <!--Mais importaÃ§Ãµes de collapse e modal-->

    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous">
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous">
    </script>

    <!--CÃ³digo Principal do jogo-->

    <script>
        "use strict"; //PrevenÃ§Ã£o de erros de sintaxe, etc//
        document.addEventListener('DOMContentLoaded', function() {
        const tetrisBackSound = document.getElementById('tetrisBackgroundMusic'); //AdiÃ§Ã£o do som de fundo//
            tetrisBackSound.addEventListener('loadedmetadata', function() {
                tetrisBackSound.volume = 0.7
                tetrisBackSound.play();
            });
        });
        const buttonClick = document.getElementById('buttonSound');
        const gameOverSound = document.getElementById('gameOverSound');
        const tetrisDrop = document.getElementById('tetrisDropSound');
        const clearSound = document.getElementById('lineClear');
        const botaoStart = document.getElementById('startButton');
        const canvas = document.getElementById("tetris"); // Achamos o canvas //
        const context = canvas.getContext("2d"); // Definimos ele como 2d atravÃ©s do context//
        context.scale(20, 20); // Passamos uma escala pra esse contexto //

        function arenaSweep() {   // FunÃ§Ã£o responsÃ¡vel por limpar as linhas da arena e contabilizar pontos //
            let rowCount = 1;  // Definimos a contagem das linhas em 1, Ã© responsÃ¡vel por saber quantas linhas foram removidas de uma vez //
            outer: for (let y = arena.length - 1; y > 0; --y) { // Outer Ã© um comando que permite que vocÃª de "break" em um loop externo utilizando um loop interno. Esse loop Ã© responsÃ¡vel por percorrer as linhas e cÃ©lulas da arena, comeÃ§ando da ultima e indo ate a primeira. //
                for (let x = 0; x < arena[y].length; ++x) {  // Aqui no caso, atravessa as cÃ©lulas da linha atual. //
                    if (arena[y][x] === 0) {  // Se o valor das posiÃ§Ãµes x e y for 0, ele continua com a verificaÃ§Ã£o ignorando a linha atual
                        continue outer;  
                    }  
                }
                const row = arena.splice(y, 1)[0].fill(0); // Caso a linha inteira esteja preenchida com 0, ela Ã© repreenchida com 0, assim, limpando a linha //
                arena.unshift(row); // Agora, essa mesma linha Ã© adicionada a parte decima da arena, fazendo com que as outras linhas venham pra baixo
                ++y; // O ++y Ã© responsÃ¡vel por pular a linha impedindo que o looping externo limpe a linha novamente (causando um bug) //
                lineClearSound(); // Sonzinho pra quando limpar a linha //
                player.score += rowCount * 10; // O score do jogador Ã© a quantia de linhas que ele quebrou * 10, se ja houver score anterior, Ã© somado ao score "novo" que o jogador fez. Exemplo: eu quebrei 2 linhas, esse valor vai ser multiplicado por 10, dito isso, 2x10 = 20. esse valor vai ser multiplicado por 3 na prÃ³xima linha do cÃ³digo, dito isso, se eu quebrar mais linhas, (atÃ© um mÃ¡ximo de 4), mais pontos eu faÃ§o. //
                rowCount *= 3;  
            }  
        }  
        function collide(arena, player) {  // FunÃ§Ã£o para verificarmos a colisÃ£o da peÃ§a do jogador com as paredes, fundo da arena ou com outras peÃ§as. //
            const m = player.matrix; // Definimos M como a matriz do jogador (peÃ§a atual) //
            const o = player.pos; // Definimos O como a posiÃ§Ã£o atual do jogador //
            for (let y = 0; y < m.length; ++y) { // Looping externo responsÃ¡vel por verificar se no eixo Y, irÃ¡ haver colisÃ£o //
                for (let x = 0; x < m[y].length; ++x) { // Mesma coisa para o eixo X //
                    if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {  // Este if Ã© responsÃ¡vel por verificar se os valores de X e Y do jogador e da arena sÃ£o diferentes de zero, levando em consideraÃ§Ã£o de que ambos sÃ³ serÃ£o considerados colididos caso estejam no mesmo espaÃ§o da matriz. //
                        return true; // Retorna true caso tenha 2 valores diferentes de 0 no mesmo espaÃ§o //
                    }  
                }  
            }  
            return false;
        }  
        function createMatrix(w, h) {  // FunÃ§Ã£o para criar a matrix do jogo de acordo com a altura e largura desejados. Nada muito complexo //
            const matrix = []; // A matrix Ã© definida como uma array vazia //
            while (h--) {  // Enquanto a altura estiver diminuindo, ele continau preenchendo a matrix com "0" //
                matrix.push(new Array(w).fill(0));
            }  
            return matrix; // Dito isso, agora a funÃ§Ã£o retorna a matrix como uma array preenchida com "0" em toda a sua altura e largura. //
        }  
        function createPiece(type) {  // FunÃ§Ã£o para a criaÃ§Ã£o das peÃ§as //
            if (type === "I") {  
                return [ // Brinque como quiser com o formato dessas peÃ§as KASKASKKAS //
                    [0, 1, 0, 0],  
                    [0, 1, 0, 0],  
                    [0, 1, 0, 0],  
                    [0, 1, 0, 0],  
                ];  
            } else if (type === "L") {  
                return [  
                    [0, 2, 0],  
                    [0, 2, 0],  
                    [0, 2, 2],  
                ];  
            } else if (type === "J") {  
                return [  
                    [0, 3, 0],  
                    [0, 3, 0],  
                    [3, 3, 0],  
                ];  
            } else if (type === "O") {  
                return [  
                    [4, 4],  
                    [4, 4],  
                ];  
            } else if (type === "Z") {  
                return [  
                    [5, 5, 0],  
                    [0, 5, 5],  
                    [0, 0, 0],  
                ];  
            } else if (type === "S") {  
                return [  
                    [0, 6, 6],  
                    [6, 6, 0],  
                    [0, 0, 0],  
                ];  
            } else if (type === "T") {  
                return [  
                    [0, 7, 0],  
                    [7, 7, 7],  
                    [0, 0, 0],  
                ];  
            }  
        }  
        function drawMatrix(matrix, offset) { // Esta funÃ§Ã£o Ã© responsÃ¡vel por dar cor as peÃ§as e desenhar elas no campo, mas ela sÃ³ serÃ¡ chamada daqui a pouco //
            matrix.forEach((row, y) => {  
                row.forEach((value, x) => {  
                    if (value !== 0) { // Aqui passamos por cada valor diferente de 0 no eixo X e Y de uma peÃ§a, dito isso, caso o valor seja diferente de "0", ("1","2","3", etc) a funÃ§Ã£o pinta a cÃ©lula de acordo com a peÃ§a. (Caso seja "1", "2" e assim por diante). //
                        const gradient = context.createLinearGradient(x + offset.x, y + offset.y, x + offset.x + 1, y + offset.y + 1);
                        switch(value) {
                            case 1: // PeÃ§a I (Vermelho neon)
                                gradient.addColorStop(0, '#FF3E4D');
                                gradient.addColorStop(1, '#FFA07A');
                                break;
                            case 2: // PeÃ§a L (Azul neon)
                                gradient.addColorStop(0, '#00FFFF');
                                gradient.addColorStop(1, '#6A5ACD');
                                break;
                            case 3: // PeÃ§a J (Verde neon)
                                gradient.addColorStop(0, '#39DF14');
                                gradient.addColorStop(1, '#000F7F');
                                break;
                            case 4: // PeÃ§a O (Amarelo neon)
                                gradient.addColorStop(0, '#FFFF00');
                                gradient.addColorStop(1, '#FF6700');
                                break;
                            case 5: // PeÃ§a Z (Roxo neon)
                                gradient.addColorStop(0, '#BF04FF');
                                gradient.addColorStop(1, '#0122CC');
                                break;
                            case 6: // PeÃ§a S (Rosa neon)
                                gradient.addColorStop(0, '#FF1493');
                                gradient.addColorStop(1, '#FF69B4');
                                break;
                            case 7: // PeÃ§a T (Laranja neon)
                                gradient.addColorStop(0, '#FFA500');
                                gradient.addColorStop(1, '#FF4500');
                                break;
                        }
                        context.fillStyle = gradient;
                        context.fillRect(x + offset.x, y + offset.y, 1, 1);
                        context.fillStyle = 'rgba(255, 255, 255, 0.05)';
                        context.fillRect(x + offset.x, y + offset.y, 1, 1);
                    }  
                });  
            });  
        }

        function drawNextPiece(piece) { // FunÃ§Ã£o responsÃ¡vel por criar o quadradinho que mostra a proxima peÃ§a (e jÃ¡ mostrar ela como consequÃªncia) //
            const canvasNextPiece = document.getElementById("nextPiece");
            const contextNextPiece = canvasNextPiece.getContext("2d"); // Definimos o mesmo contexto de 2d, mas dessa vez nÃ£o damos os parÃ¢metros anteriores de 20x20 //

            contextNextPiece.clearRect(0, 0, canvasNextPiece.width, canvasNextPiece.height); // Esta linha da clear no quadradinho para previnir que nÃ£o haja alguma peÃ§a ali e quando a outra aparecer, nÃ£o acabar sobrescrevendo a anterior //

            const cellSize = canvasNextPiece.width / 5; // Definimos um quadradinho de "5x5" //
            const offsetX = (canvasNextPiece.width - piece[0].length * cellSize) / 2; // Estas duas linhas sÃ£o responsÃ¡veis pela localizaÃ§Ã£o da peÃ§a no quadradinho, se vai ser no centro ou onde der pra ajustar //
            const offsetY = (canvasNextPiece.height - piece.length * cellSize) / 2; 
            piece.forEach((row, y) => { // Aqui fazemos a mesma coisa da func anterior para dar cor as peÃ§as que irÃ£o aparecer //
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const gradient = contextNextPiece.createLinearGradient(x * cellSize + offsetX, y * cellSize + offsetY, (x + 1) * cellSize + offsetX, (y + 1) * cellSize + offsetY);
                        switch (value) {
                            case 1: // PeÃ§a I (Vermelho neon)
                                gradient.addColorStop(0, '#FF3E4D');
                                gradient.addColorStop(1, '#FFA07A');
                                break;
                            case 2: // PeÃ§a L (Azul neon)
                                gradient.addColorStop(0, '#00FFFF');
                                gradient.addColorStop(1, '#6A5ACD');
                                break;
                            case 3: // PeÃ§a J (Verde neon)
                                gradient.addColorStop(0, '#39DF14');
                                gradient.addColorStop(1, '#000F7F');
                                break;
                            case 4: // PeÃ§a O (Amarelo neon)
                                gradient.addColorStop(0, '#FFFF00');
                                gradient.addColorStop(1, '#FF6700');
                                break;
                            case 5: // PeÃ§a Z (Roxo neon)
                                gradient.addColorStop(0, '#BF04FF');
                                gradient.addColorStop(1, '#0122CC');
                                break;
                            case 6: // PeÃ§a S (Rosa neon)
                                gradient.addColorStop(0, '#FF1493');
                                gradient.addColorStop(1, '#FF69B4');
                                break;
                            case 7: // PeÃ§a T (Laranja neon)
                                gradient.addColorStop(0, '#FFA500');
                                gradient.addColorStop(1, '#FF4500');
                                break;
                        }
                        contextNextPiece.fillStyle = gradient;
                        contextNextPiece.fillRect(x * cellSize + offsetX, y * cellSize + offsetY, cellSize, cellSize);
                        contextNextPiece.fillStyle = 'rgba(255, 255, 255, 0.05)';
                        contextNextPiece.fillRect(x * cellSize + offsetX, y * cellSize + offsetY, cellSize, cellSize);
                    }
                });
            });
        }
        
        // Duas func de som que tÃ£o meio perdidas ai //

        function buttonClickSound(){
            buttonClick.play();
        }
        
        function lineClearSound(){
            clearSound.play();
        }

        function draw() {  // Func responsÃ¡vel por fazer o fundinho da arena //
            context.fillStyle = "#000"; // Definimos o fundinho como preto (experimenta por rosa pra vc ver que engraÃ§ado) //
            context.fillRect(0, 0, canvas.width, canvas.height); // Colocamos essa cor em toda a extenÃ§Ã£o do canva //
            drawMatrix(arena, {x: 0, y: 0}); // ColocaÃ§Ã£o da peÃ§a em campo no local (arena) e posiÃ§Ã£o que queremos. //
            drawGhostPiece(); // Optei por colocar a funÃ§Ã£o de ghostpiece aqui pois assim que surge alguma peÃ§a, jÃ¡ Ã© identificada qual peÃ§a Ã© e em qual posiÃ§Ã£o ela estÃ¡ com base no offset (posiÃ§Ã£o) dela. Mais tarde essa funÃ§Ã£o vai ser melhor explicada //
            drawMatrix(player.matrix, player.pos); // Chamamos novamente a draw matrix para a matriz e para a posiÃ§Ã£o atual do jogador, definida no final do cÃ³digo //
        }  
        function merge(arena, player) {  // FunÃ§Ã£o para integrar a peÃ§a ao campo, junto a matriz e as outras peÃ§as do jogador //
            player.matrix.forEach((row, y) => {  
            row.forEach((value, x) => {  
                if (value !== 0) {  // Percorremos novamente por cada linha e em cada cÃ©lula verificando se o valor Ã© diferente de 0. Se for, ele define que essa posiÃ§Ã£o atual da peÃ§a agora serÃ¡ o novo valor nas posiÃ§Ãµes x e y tanto da arena quanto do jogador. //
                arena[y + player.pos.y][x + player.pos.x] = value;  
                }  
            });  
        });  
        }  
        function rotate(matrix, dir) { // Func responsÃ¡vel por rotacionar a peÃ§a //
            for (let y = 0; y < matrix.length; ++y) { 
                for (let x = 0; x < y; ++x) { 
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; // Dentro do loop, os elementos sÃ£o trocados de posiÃ§Ã£o, entÃ£o, o que era x vira y e o que era y vira x (bem confuso) // 
                }  
            }  
            if (dir > 0) { // Se o valor for positivo, rotaciona em sentido horÃ¡rio, se for negativo, rotaciona no inverso (anti-horÃ¡rio) //
                matrix.forEach((row) => row.reverse());  
            } 
            else {  
                matrix.reverse();  
            }  
        } 
        function playerDrop() { // Func para a peÃ§a simplesmente cair //
            player.pos.y++;
            if (collide(arena, player)) { // Se colidir com alguma coisa enquanto estiver caindo: volta 1 posiÃ§Ã£o do eixo y para que a peÃ§a nÃ£o fique dentro da outra. Irei tentar explicar por texto como funciona a colisÃ£o: Se a peÃ§a entrar dentro da arena ou de outra peÃ§a (cujos valores sÃ£o diferentes de 0), a func collide retorna o valor true, dizendo que ali houve colisÃ£o de dois corpos. //
                player.pos.y--; // Dito isso, agora volta 1 posiÃ§Ã£o //
                merge(arena, player); // Integra a posiÃ§Ã£o daquela peÃ§a a arena fazendo com que fique "fixa" ali //
                playerReset(); // Faz uma nova peÃ§a aparecer no campo //
                arenaSweep(); // Chama a funÃ§Ã£o que percorre a arena para verificar se houve uma linha inteira preenchida com valor diferente de 0, se houver, jÃ¡ limpa e conta a pontuaÃ§Ã£o //
                updateScore(); // Atualiza o score do jogador //
            }
            dropCounter = 0; // Define tambÃ©m a contagem de "dropagem" (nÃ£o consigo pensar em outro termo) em 0. //
        }
        function playerMove(offset) {  // FunÃ§Ã£o para mover a peÃ§a do jogador. //
            player.pos.x += offset;  // PosiÃ§Ã£o no eixo X do jogador somada a posiÃ§Ã£o passada no parÃ¢metro //
            if (collide(arena, player)) {  // Se colidir, o eixo X do jogador Ã© impedido de progredir pois sempre serÃ¡ subtraida pela posiÃ§Ã£o //
                player.pos.x -= offset;  
            }  
        }  

        let shuffledPieces = shufflePieces(); // Definimos uma variÃ¡vel com as peÃ§as embaralhadas //

        function shufflePieces() { // Func para embaralhar as peÃ§as (balancear o jogo) //
            const pieces = "TJLOSZI".split(''); // Pegamos todas as peÃ§as e dividimos todas em strings Ãºnicas //
            // Embaralhe as peÃ§as usando o algoritmo de Fisher-Yates //
            for (let i = pieces.length - 1; i > 0; i--) { // Looping para sempre pegar peÃ§as diferentes e nunca repetir duas peÃ§as seguidas //
                const j = Math.floor(Math.random() * (i + 1)); // Faz aquela parada maluca do fisher-yates que nao sei explicar //
                [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
            }
            return pieces; // Retorna essas peÃ§as agora embaralhadas //
        }
        const pieceFrequency = { // Define que cada uma das peÃ§as agora tem um valor inicial de "0", que logo serÃ¡ aumentado //
            "T": 0,
            "J": 0,
            "L": 0,
            "O": 0,
            "S": 0,
            "Z": 0,
            "I": 0
        };
        function playerReset() { // FunÃ§Ã£o que faz a peÃ§a aparecer no campo //
            const selectedPiece = shuffledPieces.pop(); // Pegamos a peÃ§a que irÃ¡ aparecer e dizemos que essa peÃ§a serÃ¡ a Ãºltima peÃ§a do array de peÃ§as embaralhadas // 
            
            drawNextPiece(createPiece(shuffledPieces[shuffledPieces.length - 1])); // aqui dizemos que a prÃ³xima peÃ§a a aparecer no quadradinho de prÃ³ximas peÃ§as, serÃ¡ o valor das peÃ§as embaralhadas - 1, dito isso, serÃ¡ uma peÃ§a depois da peÃ§a atualmente em campo. //
            
            player.matrix = createPiece(selectedPiece); // Criamos a peÃ§a com a peÃ§a jÃ¡ escolhida das peÃ§as embaralhadas //
            player.pos.y = 0; // Definimos que ela irÃ¡ aparecer nesta posiÃ§Ã£o do eixo Y e X //
            player.pos.x = Math.floor((arena[0].length / 2) - (player.matrix[0].length / 2));
            
            if (collide(arena, player)) { // Se agora a peÃ§a do jogador colidir com a nova peÃ§a desenhada, serÃ¡ retornada a funÃ§Ã£o de gameOver, que para o jogo, jÃ¡ jÃ¡ chegamos nela. //
                gameOver(player.level);
                return;
            }
            pieceFrequency[selectedPiece]++; // Aqui aumentamos a frequÃªncia de peÃ§as daquela array anterior que definimos como 0, essa frequÃªncia serÃ¡ adicionada com base na peÃ§a selecionada atualmente, fazendo com que sempre haja esse balanceamento correto das peÃ§as //

            shuffledPieces.unshift(selectedPiece); // Faz com que a peÃ§a selecionada seja adicionada ao array de peÃ§as embaralhadas na Ãºltima posiÃ§Ã£o, fazemdo com que haja uma fila que serÃ¡ sempre reembaralhada //
        }

        function playerRotate(dir) {  // Func que irÃ¡ rotacionar a peÃ§a //
            const pos = player.pos.x; // Definie a posiÃ§Ã£o como a posiÃ§Ã£o X do jogador para caso nÃ£o seja possÃ­vel rotacionar, sendo assim, volta a posiÃ§Ã£o original //
            let offset = 1; // Define a posiÃ§Ã£o offset como 1 //
            rotate(player.matrix, dir); // Chama a func rotate com os parÃ¢metros da peÃ§a do jogador e em qual posiÃ§Ã£o ele irÃ¡ rotacionar (positiva ou negativa)
            while (collide(arena, player)) { // Definimos um loop para caso a peÃ§a esteja colidindo com algum elemento //
                player.pos.x += offset; // Basicamente nas linhas abaixo, os valores sÃ£o verificados para compreender se serÃ£o positivos ou negativos. Caso haja um valor positivo, a peÃ§a tentarÃ¡ rotacionar para a direita, enquanto o contrÃ¡rio ocorrerÃ¡ para o outro lado. Quando chegamos no if, ele verifica se hÃ¡ possibilidade de rotacionar para qualquer lado, se nÃ£o for possÃ­vel, sÃ³ retornamos a posiÃ§Ã£o original (salva na constante "pos"). //
                offset = -(offset + (offset > 0 ? 1 : -1));  
                if (offset > player.matrix[0].length) {  
                    rotate(player.matrix, -dir);  
                    player.pos.x = pos;
                    return;  
                }  
            }  
        }
        function start(){ // FunÃ§Ã£o para comeÃ§ar o jogo //
            $('#startButton').blur(); // Tiramos o foco do botÃ£o //
            document.getElementById('rightSide').style.display = 'block';
            document.getElementById('canva-score').style.display = 'flex';
            arena.forEach((row) => row.fill(0)); // Primeiro limpamos toda a arena para caso houvesse alguma peÃ§a nela (caso seja a segunda vez jogando) //
            playerReset(); // Chamamos a funÃ§Ã£o que gera peÃ§a //
            update(); // Chamamos a funÃ§Ã£o que atualiza o jogo a todo instante //
            document.getElementById('gameOverScreen').style.display = 'none'; // Definimos que agora a tela de gameOver deve estar escondida dnv caso seja a segunda vez jogando (ou mais) //
            dropInterval = 500; // Definimos novamente o drop interval para 500 //
            player.score = 0; // O score Ã© resetado para 0 tambÃ©m //
            updateScore(); // Atualizamos o score na tela //
            stopLevelUpdate(); // Pare o intervalo de atualizaÃ§Ã£o do nÃ­vel antes de iniciar um novo jogo //
            player.level = 0; // Redefina o nÃ­vel do jogador para o valor inicial //
            showLevel(); // Mostramos o lvl atualizado na tela //
            startLevelUpdate(); // ComeÃ§amos novamente a contar o level //
        }
        function showGameOver() { // SÃ³ mostramos a tela de gameOver na tela //
            document.getElementById('gameOverScreen').style.display = 'block';
        }
        // Defina uma variÃ¡vel para controlar o intervalo de atualizaÃ§Ã£o do nÃ­vel
        let levelUpdateInterval; // VariÃ¡vel que vai armazenar o intervalo que o lvl vai aumentar //

        // FunÃ§Ã£o para atualizar o nÃ­vel do jogador com base no tempo decorrido //
        function updateLevel() {
            player.level++; // Aumenta o nÃ­vel do jogador //
            dropInterval -= 20; // Reduz o intervalo de queda para aumentar a velocidade do jogo //
            showLevel(); // Atualiza a exibiÃ§Ã£o do nÃ­vel //
        }
        // FunÃ§Ã£o para iniciar o intervalo de atualizaÃ§Ã£o do nÃ­vel //
        function startLevelUpdate() {
            levelUpdateInterval = setInterval(updateLevel, 20000); // Atualiza o nÃ­vel a cada 20 segundos //
        }

        // FunÃ§Ã£o para parar o intervalo de atualizaÃ§Ã£o do nÃ­vel (se necessÃ¡rio) //
        function stopLevelUpdate() {
            clearInterval(levelUpdateInterval);
        }

        // FunÃ§Ã£o para exibir o nÃ­vel do jogador //
        function showLevel() {
            let nivelJogador = String(player.level).padStart(3, '0'); // Colocamos 3 zeros na tela //
            document.getElementById("nivel").innerText = "Level: " + nivelJogador; // Adicionamos o lvl atual com a string "Level" //
        }
        function gameOver(nivelJogador) { // FunÃ§Ã£o que acaba com o jogo (o parÃ¢metro estÃ¡ ai pois foi a Ãºnica maneira que consegui incluir o level atual do jogador na datatable) //
            gameOverSound.play(); // Toca o som de fim //
            showGameOver(); // Mostra a tela de game over //
            console.log("Game Over!"); // Console Log //
            dropInterval = 9999999; // Drop Interval infinito pra nao cair nenhuma peÃ§a //
            player.pos.y = -10; // Jogamos as peÃ§as 10 px pra cima do canvas, assim ngm vai ver a peÃ§a ali paradinha //
            stopLevelUpdate() // Paramos a contagem de lvl //
            let playerName = prompt("Digite seu nome:"); // Perguntamos o nome e sobrenome //
            let playerPartnerName = prompt("Digite o seu sobrenome:");

            playerName = playerName.substring(0, 14); // MÃ¡ximo de 14 caracteres para ambos //
            playerPartnerName = playerPartnerName.substring(0, 14);

            const date = new Date().toLocaleDateString(); // Salvamos a data e score atual do jogador //
            const score = player.score;


            addScoreToTable(playerName, playerPartnerName, nivelJogador, score, date);

            saveScoreboardData(); // Salvamos as informaÃ§Ãµes do scoreboard nesta funÃ§Ã£o //
        }
        function playerHardDrop() { // funÃ§Ã£o de HardDrop //
            const originalPos = { ...player.pos }; // Copiamos a posiÃ§Ã£o atual do jogador nesta constante //
            while (!collide(arena, player)) { // Enquanto nÃ£o colidir, aumenta o Y o mÃ¡ximo que conseguir //
                player.pos.y++;
            }
            player.pos.y--; // Voltamos 1 quando colidir //
            if (!collide(arena, player)) { // Como voltamos uma posiÃ§Ã£o, agora enquanto nÃ£o colidir, podemos mover a peÃ§a para os lados depois de dar hard drop para podermos fazer a jogadinha ðŸ˜Ž //
                var moveDelay = 100; // Delay de 100 ms para ser difÃ­cel de fazer a jogadinha //
                let currentTime = performance.now(); // Usamos performance pois como queremos ter uma precisÃ£o muito exata, o performance Ã© o Ãºnico que consegue entregar tanta precisÃ£o de resposta //
                let allowMove = true; // Permitimos o movimento //

                const moveHandler = (event) => {
                    if (allowMove) { // Se for permitido o movimento, escreva sua histÃ³ria ðŸ¤  //
                        if (event.keyCode === 37) { 
                            playerMove(-1);
                            allowMove = false; 
                        } else if (event.keyCode === 39) { 
                            playerMove(1);
                            allowMove = false; 
                        }
                    }
                };

                document.addEventListener("keydown", moveHandler);

                setTimeout(() => {
                    document.removeEventListener("keydown", moveHandler);
                }, moveDelay);
            }
        }

        function drawGhostPiece() { // Func que irÃ¡ desenhar a peÃ§a fantasma na arena //
            let ghostPiecePosition = { ...player.pos }; // Copia a posiÃ§Ã£o do jogador //
            while (!collide(arena, { matrix: player.matrix, pos: { ...ghostPiecePosition } })) { // Enquanto a peÃ§a copiada do jogador nÃ£o colidir com a arena, ele incrementa a ghostpiece no eixo y //
                ghostPiecePosition.y++;
            }
            ghostPiecePosition.y--; // Quando colidir, volta 1 posiÃ§Ã£o do eixo Y //

            player.matrix.forEach((row, y) => { // Definimos uma corzinha transparente e escura para a peÃ§a fantasma //
                row.forEach((value, x) => {  
                    if (value !== 0) {
                        context.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        context.fillRect(x + ghostPiecePosition.x, y + ghostPiecePosition.y, 1, 1);
                    }
                });
            });
        }
 
        function addScoreToTable(playerName, playerPartnerName, nivelJogador, score, date) { // FunÃ§Ã£o para adicionar todas as informaÃ§Ãµes salvas anteriormente na datatable //
            if (scoreboardTable) {
                const deleteButton = `<button class="botao-de-exclusao" onclick="deleteScore(event)"></button>`;
                scoreboardTable.row.add([ // Adiciona essas informaÃ§Ãµes na datatable //
                    playerName,
                    playerPartnerName,
                    nivelJogador,
                    score,
                    date,
                    deleteButton,
                ])  .draw(); 
            }
        }
        function deleteScore(event) { // FunÃ§Ã£o para apagar a linha da datatable com o botaozinho (essa funÃ§Ã£o Ã© chamada no "deleteButton" // 
            const row = event.target.closest('tr'); // Identificamos o TR mais prÃ³ximo e definimos que ele serÃ¡ nossa constante "row" (linha) //
            const rowIndex = scoreboardTable.row(row).index(); // ObtÃ©m o Ã­ndice da linha na tabela
            const data = JSON.parse(localStorage.getItem('scoreboardData')); // Deifinimos que os dados sÃ£o as informaÃ§Ãµes salvas dentro do JSON localStorage //
            if (data) {
                data.splice(rowIndex, 1); // Remove os dados associados ao Ã­ndice da linha
                localStorage.setItem('scoreboardData', JSON.stringify(data));
            }
            scoreboardTable.row(row).remove().draw(); // Removemos a linha //
        }
        function loadScoreboardData() { // Carregamos as informaÃ§Ãµes anteriormente salvas no localStorage //
            const data = localStorage.getItem('scoreboardData'); // Pegamos as info salvas //
            if (data) {
                const scoreboardData = JSON.parse(data);
                scoreboardData.forEach(row => {
                    addScoreToTable(row[0], row[1], row[2], row[3], row[4], row[5]); // Adicionamos elas em local certinho //
                });
            }
        } 
        function saveScoreboardData() { // FunÃ§Ã£o para salvarmos as informaÃ§Ãµes no localStorage //
            const data = scoreboardTable.rows().data().toArray(); 
            localStorage.setItem('scoreboardData', JSON.stringify(data));
        }
        function showControls() { // Collapse que mostra os comandos //
            controlsBox.style.display = "block";
        }
        let dropCounter = 0; // VariÃ¡vel que define a contagem de drops em 0 //
        let dropInterval = 1000; // VariÃ¡vel que define o intervalo de drop das peÃ§as em 1000 ms //
        let lastTime = 0; // VariÃ¡vel que usaremos para atualizar o jogo //
        function update(time = 0) { // FunÃ§Ã£o para atualizar o jogo a todo o momento //
            const deltaTime = time - lastTime; // Calcula o intervalo entre o tempo atual e o Ãºltimo atualizado //
            dropCounter += deltaTime; // Adiciona o tempo atualizado com o dropCounter para controlar a velocidade do jogo //
            if (dropCounter > dropInterval) { // Verifica se o valor atualizado excede o valor de queda //
                playerDrop(); // Se sim, cai uma linhazinha
            }  
            lastTime = time; // Atualizamos agora o lastTime como o Time atual para que depois, quando a funÃ§Ã£o for chamada novamente, sempre salve a atualizaÃ§Ã£o correta //
            draw(); // Atualiza o jogo //
            requestAnimationFrame(update); // Inicializa um loop infinito que sempre atualiza o jogo a todo o instante enquanto estiver em execuÃ§Ã£o // 
        }  
        function updateScore() {  // Atualiza o score na tela //
            let formattedScore = String(player.score).padStart(4, '0');  
            document.getElementById("score").innerText = "Score: " + formattedScore;  
        } 
        
        // MovimentaÃ§Ã£o do jogador //

        document.addEventListener("keydown", (event) => {  
            if (event.keyCode === 37) {  
                playerMove(-1);  
            } 
            else if (event.keyCode === 39) {  
                playerMove(1);  
            } 
            else if (event.keyCode === 40) {  
                playerDrop();  
            } 
            else if (event.keyCode === 65) {  
                playerRotate(-1);  
            } 
            else if (event.keyCode === 68) {  
                playerRotate(1);  
            }  
            else if (event.keyCode === 32) { // Tecla de espaÃ§o para hard drop
                playerHardDrop();
                tetrisDrop.play();
            }
        });  
        // Definimmos o quadradinho como 5x5 //
        const arenaNextPiece = createMatrix(5, 5);
        // Definimos a arena como 12x20 //
        const arena = createMatrix(12, 20);  
        // Fazemos todas as variaÃ§Ãµes para o player
        const player = {  
            pos: { x: 0, y: 0 },  
            matrix: null,  
            score: 0,  
            level: 0,
        };
        // Atualizamos o score quando inicia a pÃ¡gina //
        updateScore();
        // Atualizamos o lvl quando inicia a pÃ¡gina //
        showLevel();
    </script>
</body>
</html>